## Artificial Intelligence Use:

In accordance with the course's policy on the use of artificial intelligence for the final project, I used ChatGPT (www.chatgpt.com), Copilot (https://copilot.microsoft.com), and Cursor. Each played a separate role which I will outline here.

ChatGPT was used to condense all of my thoughts into a project outline. It then provided a lengthy list of sites for me to learn how I would begin implementing some of these ideas in my code. ChatGPT also provided clear directions on how I could implement Google Sign In and how to navigate Google Cloud Console so that I could begin learning how to use it. ChatGPT also guided me through implementing Node.js and how to download all necessary files as well as how I would be able to move everything to GitHub. The largest contribution of ChatGPT was writing the server.js file which I needed fully completed to begin testing my code that I wrote, which was the basic outline of the website. I wanted to ensure that the server file was correctly coded by making sure to prompt to fix all vulnerabilities. I eventually plan on publishing the site, and I would not want my inexperience from only taking an introductory class to risk mishandling user data as a significant portion of my project allows for the option to sign into Google. Finally, ChatGPT assisted in creating the cell grid and heatmap as this was a feature I really wanted to add but was outside of my current skill level. 

Copilot was originally used as it was built into the Visual Studio Code application. It was mainly used to fill in the gaps of my own code, making a skeleton of a website into something visually appealing and smooth. While all of the CSS and HTML layout formatting was something I had done in high school, Copilot allowed me to bring the basic design I had planned out into a full website with correct spacing and formatting even on a mobile device. Copilot was also extremely helpful in implementing helper functions relating to Google Sign In and Google Calendar as it significantly expedited understanding the documentation, which would have normally taken me weeks to understand. However, the issue I had encountered was that Copilot required frequent reprompting as it would often not provide a desired result, eventually leading me to run out of tokens. Copilot was used to help debug code I encountered while trying to fix issues on the site itself, such as misalignment with containers.

Finally, Cursor handled most of the late-stage tasks. I was able to prompt it to try to fix all vulnerabilties as doing so was beyond the extent of my current knowledge. Mainly, this prevented any particular user from being able to mess up the site for everyone else. Next, I had Cursor run through all of my code, simplifying a lot of the code in main.js, filling in gaps that I had missed, and removing extraneous code that I didn't need. I was able to also use Cursor to help with adding in documentation that I had missed, saving a lot of time. Overall, Cursor fixed bugs and vulnerabilties that were beyond my abilities, fixed functions that didn't work, improved perfomance, and did all of the final checking to beautify and tie together different parts of my website code, handling a large volume of code that would have taken too much time to track.

## Technical Overview:

Compared to a traditional app store application, a website just seemed like a much more effective idea, especially as it mimics When2Meet in terms of ease of access. HSync combines both a traditional frontend with a server backend to form the design of the site. The frontend is a vanilla JavaScript single-page application that communicates with a Node.js/Express backend via RESTful API endpoints. I chose to use Google OAuth 2.0 for authentication as it is the standard procedure for connecting to the Google Calendar API which aassists in preventing users from double-booking themselves. The frontend uses Javascript and not any significant frameworks and behaves like a normal HTML document with each page being its own HTML file. DOM is used to manipulate elements of the HTML page, while the ChatGPT chosen fetch API handles HTTP communication with the backend through a 'fetchJson' wrapper. 

The backend is built on Express.js and stores the data in-memory what was chosen as it is compatible with Node.js. Authentication is handled through Google OAuth 2.0, where the frontend obtains a Google ID token via Google Identity Services, sends it to the backend which verifies the token using Google's OAuth2Client library. Input validation prevents injection attacks, and slot indices are validated and clamped to valid ranges to prevent out-of-bounds access. To secure data, I decided to go with what ChatGPT recommended which was a RESTful API pattern. This allows the frontend to collect the form data and POST to the backend to validate the data. To ensure that each event is unique, an 8 character event id is created which is stored in memory. 

The calendar integration uses a two-token system: Google ID tokens for authentication and Google Calendar API access tokens for calendar data retrieval. The frontend uses Google Identity Services to obtain ID tokens for sign-in, which are sent to the backend for session creation. The calendar overlay process involves fetching events from the user's primary Google Calendar for the event's date and time range, then computing which availability grid slots overlap with calendar events by comparing time ranges. The frontend builds time range objects for each slot using the event's start time, slot duration, and date information, then iterates through calendar events to find overlaps which are marked with the busy CSS class and event details are stored for tooltip display on hover.

My choices leave me with a lot of flexibility in the future, as I can always use React to expedite the site-making process. As the tokens and data is stored properly through the backend, I feel comfortable implementing a more comprehensive Google integration in the future, allowing for potential increased functionality that is optional so that it doesn't affect simplicity. 

## Design:

I wanted to keep the design visually appealing, yet simple. As my original theme was Harvard, the overall color scheme was chosen to be crimson while I was also able to use w3schools to add in extra features like button shadowing. I originally had another tab that allowed you to change the appearance of the site itself, but I removed it as I was having complications, and I thought it would clutter the site. I was set on the cell grid heatmap, as that is what the When2Meet website uses, but I wanted the cells to be larger, so it would be easier to use on mobile. I found the current process to enter in the time to be a little cumbersome, but it allows entering the time on mobile to be extremely simple, as it is the scrolling wheel that we are all used to, making me ultimately keep it. Additionally, while the calendar only originally contained the overlay, I wanted users to be able to see when they were actually busy and for what reason, so I added the feature that shows the event on hover. There are still many things in the design that need to be fixed as they are inconvenient, but they do not affect the core functionality of the website. 

